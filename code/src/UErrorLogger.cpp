#include "UErrorLogger.h"

namespace VolkPhetamine {

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////  ================================================================================================================================  ////
	////    ---- Constructor/Destructor -----                                                                                               ////
	////  ================================================================================================================================  ////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//----------------------------------------------------------------------------------------------------------------------------------------//
	/// At destruction: Close the output stream if it's open
	//----------------------------------------------------------------------------------------------------------------------------------------//
	UErrorLogger::~UErrorLogger() {
		if (m_outputStream.is_open()) {
			m_outputStream.close();
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////  ================================================================================================================================  ////
	////    ---- Setter -----                                                                                                               ////
	////  ================================================================================================================================  ////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//----------------------------------------------------------------------------------------------------------------------------------------//
	/// For error redirection (into a streamfile)
	//----------------------------------------------------------------------------------------------------------------------------------------//
	void UErrorLogger::setOutputFile(vlString a_fileName) {
		m_outputStream.open(a_fileName);
		m_isErrorStreamSpecified = true;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////  ================================================================================================================================  ////
	////    ---- Core -----                                                                                                                 ////
	////  ================================================================================================================================  ////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//----------------------------------------------------------------------------------------------------------------------------------------//
	/// Called from VK_ERROR_CONTINUE: Displays the stack
	//----------------------------------------------------------------------------------------------------------------------------------------//
	void UErrorLogger::display(vlString a_errorMessage, vlString a_context) {
		std::streambuf* originErrorStream = nullptr; // Saving cerr stream
		std::stack<std::string> backupStack; // Backup for stack (if non blocking error, we want to keep the context!)
		std::string currentMessage;
		std::string callStack;

		// Drop context/messages for display (update backup stack)
		while (!m_errorCallStack.empty()) {
			currentMessage = m_errorCallStack.top();
			if (currentMessage != M_STACK_TRACE_MARK) {
				callStack += "\t" + m_errorCallStack.top();
			}
			backupStack.push(m_errorCallStack.top());
			m_errorCallStack.pop();
		}

		// If stream is redirected to file, redirect cerr to this streamfile
		if (m_isErrorStreamSpecified) {
			originErrorStream = std::cerr.rdbuf();
			std::cerr.rdbuf(m_outputStream.rdbuf());
		}

		// Display error message and call stack
		std::cerr << a_errorMessage << std::endl;
		std::cerr << a_context << std::endl;
		std::cerr << callStack;

		// Rebind cerr if binded to streamfile
		if (m_isErrorStreamSpecified) {
			std::cerr.rdbuf(originErrorStream);
		}

		// Restore call stack from backup
		while (!backupStack.empty()) {
			m_errorCallStack.push(backupStack.top());
			backupStack.pop();
		}
	}

	//----------------------------------------------------------------------------------------------------------------------------------------//
	/// Called from VK_ERROR: Displays the stack and causes exit()
	//----------------------------------------------------------------------------------------------------------------------------------------//
	void UErrorLogger::displayAndCrash(vlString a_errorMessage, vlString a_context) {
		display(a_errorMessage, a_context);
		if (m_outputStream.is_open()) {
			m_outputStream.close();
		}
		exit(EXIT_FAILURE);
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////  ================================================================================================================================  ////
	////    ---- Static -----                                                                                                               ////
	////  ================================================================================================================================  ////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//----------------------------------------------------------------------------------------------------------------------------------------//
	/// Singleton pattern stuff (unique creation only)
	//----------------------------------------------------------------------------------------------------------------------------------------//
	UErrorLogger& UErrorLogger::getInstance() {
		static UErrorLogger* errorHandler = nullptr;
		if (errorHandler == nullptr) {
			errorHandler = new UErrorLogger();
		}

		return *errorHandler;
	}

	//----------------------------------------------------------------------------------------------------------------------------------------//
	/// Singleton pattern stuff (unique delete only)
	//----------------------------------------------------------------------------------------------------------------------------------------//
	void UErrorLogger::destroyInstance() {
		static UErrorLogger* errorHandler = &getInstance();
		if (errorHandler != nullptr) {
			delete errorHandler;
		}
	}

}