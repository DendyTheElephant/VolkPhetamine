#include "UErrorLogger.h"

namespace VolkPhetamine {
	namespace Utils {

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		////  ================================================================================================================================  ////
		////    ---- Constructor/Destructor -----                                                                                               ////
		////  ================================================================================================================================  ////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// At destruction: Close the output stream if it's open
		//----------------------------------------------------------------------------------------------------------------------------------------//
		UErrorLogger::~UErrorLogger() {
			if (m_outputStream.is_open()) {
				m_outputStream.close();
			}
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		////  ================================================================================================================================  ////
		////    ---- Setter -----                                                                                                               ////
		////  ================================================================================================================================  ////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// For error redirection (into a streamfile)
		//----------------------------------------------------------------------------------------------------------------------------------------//
		void UErrorLogger::setOutputFile(vlString a_fileName) {
			m_outputStream.open(a_fileName);
			m_isErrorStreamSpecified = true;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		////  ================================================================================================================================  ////
		////    ---- Core -----                                                                                                                 ////
		////  ================================================================================================================================  ////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// Called from VK_ERROR_CONTINUE: Displays the stack
		//----------------------------------------------------------------------------------------------------------------------------------------//
		void UErrorLogger::display(vlString a_errorMessage, vlString a_context) {
			std::streambuf* originErrorStream = nullptr; // Saving cerr stream
			std::stack<std::string> backupStack; // Backup for stack (if non blocking error, we want to keep the context!)
			std::string currentMessage;
			std::string callStack;

			// Drop context/messages for display (update backup stack)
			while (!m_errorCallStack.empty()) {
				currentMessage = m_errorCallStack.top();
				if (currentMessage != M_STACK_TRACE_MARK) {
					callStack += "\t" + m_errorCallStack.top();
				}
				backupStack.push(m_errorCallStack.top());
				m_errorCallStack.pop();
			}

			// If stream is redirected to file, redirect cerr to this streamfile
			if (m_isErrorStreamSpecified) {
				originErrorStream = std::cerr.rdbuf();
				std::cerr.rdbuf(m_outputStream.rdbuf());
			}

			// Display error message and call stack
			std::cerr << a_errorMessage << std::endl;
			std::cerr << a_context << std::endl;
			std::cerr << callStack;

			// Rebind cerr if binded to streamfile
			if (m_isErrorStreamSpecified) {
				std::cerr.rdbuf(originErrorStream);
			}

			// Restore call stack from backup
			while (!backupStack.empty()) {
				m_errorCallStack.push(backupStack.top());
				backupStack.pop();
			}
		}

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// Called from VK_ERROR: Displays the stack and causes exit()
		//----------------------------------------------------------------------------------------------------------------------------------------//
		void UErrorLogger::displayAndCrash(vlString a_errorMessage, vlString a_context) {
			display(a_errorMessage, a_context);
			if (m_outputStream.is_open()) {
				m_outputStream.close();
			}
			exit(EXIT_FAILURE);
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		////  ================================================================================================================================  ////
		////    ---- Static -----                                                                                                               ////
		////  ================================================================================================================================  ////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// Singleton pattern stuff (unique creation only)
		//----------------------------------------------------------------------------------------------------------------------------------------//
		UErrorLogger& UErrorLogger::getInstance() {
			static UErrorLogger* errorHandler = nullptr;
			if (errorHandler == nullptr) {
				errorHandler = new UErrorLogger();
			}

			return *errorHandler;
		}

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// Singleton pattern stuff (unique delete only)
		//----------------------------------------------------------------------------------------------------------------------------------------//
		void UErrorLogger::destroyInstance() {
			static UErrorLogger* errorHandler = &getInstance();
			if (errorHandler != nullptr) {
				delete errorHandler;
			}
		}

		//----------------------------------------------------------------------------------------------------------------------------------------//
		/// GLFW Error callback function
		//----------------------------------------------------------------------------------------------------------------------------------------//
		void UErrorLogger::glfwErrorCallback(vlInt a_error, const char* a_description) {
			std::cerr << "GLFW Error ID=" << a_error << " : " << a_description << std::endl;
		}
	}
}