////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////====================================================================================================================================////
/// | \file		HSingleton
///	| \author	Daniel Huc
/// | \date		February 2017
/// |----------------------------------------------------------------------------------------------------------------------------------
/// | \brief	Simple singleton implementation
/// | \details	Teamplated class that ensures the sigleton pattern
////====================================================================================================================================////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma once
/* Standard library includes */
#include <mutex>


/* Internal headers includes */
#include "HInternalTypeAliases.h"

namespace VolkPhetamine {
	
	template <typename T>
	class vlSingleton {
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//// ---- Members -----																													//// 
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private:
		static vlUniquePtr<T> m_instance;	///< Unique instance of the Sigleton class
		static std::once_flag m_once;		///< Thread safety


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//// ---- Methods -----																													////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private:
		/// Private constructor
		vlSingleton<T>() { /* VOID */ }
		vlSingleton<T>(const vlSingleton& original); /// Copy constructor, needed for lambda declaration of getUniqueInstance
		

	public:
	//// ---- Constructor/Destructor ---- ////
		~vlSingleton<T>() {/* VOID */ };

	//// ---- Getter ---- ////
		static T& getUniqueInstance() {
			std::call_once(vlSingleton::m_once, 
				[]() { vlSingleton::m_instance.reset(new T()); }
			);
			return *m_instance.get();
		}
	};


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//// ---- Global initialisation -----																									////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	vlUniquePtr<T> vlSingleton<T>::m_instance;

	template<typename T>
	std::once_flag vlSingleton<T>::m_once;
}
